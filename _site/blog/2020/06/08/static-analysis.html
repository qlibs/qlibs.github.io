<!doctype html>
<html lang="en">
  <head>
  <meta name="charset" content="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="The Nim programming language is a concise, fast programming language that compiles to C, C++ and JavaScript.">
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/assets/img/logo_bw.png" />

  
  <title>Static Analysis - Nim Blog</title>
  
  <link rel="stylesheet" href="/assets/css/pure.min.css">
  <link rel="stylesheet" href="/assets/css/pure-grids-responsive.min.css">
  <link href="https://use.fontawesome.com/releases/v5.0.2/css/all.css" rel="stylesheet">
  <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->
  
  <link rel="stylesheet" href="/assets/css/highlight/github.css">
  

  <link rel="stylesheet" href="/assets/css/google-fonts.css">
  <link rel="stylesheet" href="/assets/css/main.css?t=1721738524015683587">

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-48159761-1', 'auto');
    ga('send', 'pageview');

  </script>

  <script defer data-domain="nim-lang.org" src="https://plausible.io/js/plausible.js"></script>

  <meta name="twitter:title" content="Static Analysis">

  
  <meta name="twitter:description" content="Nim is in an excellent position to “get married” with static analysis, and it doesn’t have to be based on some intermediate representation but can achieve a solution more similar to Spark.">
  <meta property="og:description" content="Nim is in an excellent position to “get married” with static analysis, and it doesn’t have to be based on some intermediate representation but can achieve a solution more similar to Spark.">
  

  <meta name="twitter:site" content="@nim_lang">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://nim-lang.org/assets/img/twitter_banner.png">

  <meta property="og:title" content="Static Analysis" />
  <meta property="og:site_name" content="Nim Programming Language" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://nim-lang.org/assets/img/twitter_banner.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="1000" />
  <meta property="og:image:height" content="500" />
  <meta property="og:image:alt" content="Nim Programming Language" />
</head>

  <body class="site">
    <header>
  <nav class="pure-menu pure-menu-horizontal pure-menu-scrollable">
    <div class="nav-content">
      <a href="/" class="pure-menu-heading pure-menu-link site-logo-container">
        <img class="site-logo" src="/assets/img/logo.svg" height="28" alt="Nim">
      </a>
      <ul class="pure-menu-list">
        
        <li class="pure-menu-item">
          <a href="/blog.html"
             class="pure-menu-link current">
            Blog
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/features.html"
             class="pure-menu-link ">
            Features
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/install.html"
             class="pure-menu-link ">
            Download
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/documentation.html"
             class="pure-menu-link ">
            Documentation
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://forum.nim-lang.org"
             class="pure-menu-link ">
            Forum
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/donate.html"
             class="pure-menu-link ">
            Donate
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://github.com/nim-lang/Nim">Source</a>
        </li>
      </ul>
    </div>
    <div class="menu-fade"></div>
  </nav>
</header>

    <div class="site-content post-page">
      <div class="content">
        <div class="width-reduced">
          <h1 class="post-title">
            Static Analysis
          </h1>
          <h3 class="post-meta">
            <span>
              <i class="far fa-calendar-alt" aria-hidden="true"></i>
              08 June 2020
            </span>
            
            <span>
              <i class="fa fa-user-circle" aria-hidden="true"></i>
              Moerm
            </span>
            
          </h3>
          <div class="sidebarblock">
  <div class="content">
    <div class="title">Guest post</div>
    <div class="paragraph">
      This is a guest post by Moerm. If you would like to publish articles as a guest author on nim-lang.org then get in touch with us via
      <a href="https://twitter.com/nim_lang">Twitter</a> or <a href="https://nim-lang.org/community.html">otherwise</a>.
    </div>
  </div>
</div>

<h2 id="intro">Intro</h2>

<p>What is static analysis (SA)?
Well, static means ‘not dynamic’, i.e. not at or via runtime.
Static analysis is something that is done at or near compile time in the context of software development.
But static analysis is just one part of the formal chain, which is usually not fully used except for critical systems, such as train control systems.</p>

<p>The full formal chain starts with formal specification, an important pre-requisite of which is formal requirement assessment.
This part deals with the question “<em>what</em> is some software to do?”.</p>

<p>The next step is formal design and modelling which deals with the question of <em>how</em> the software is doing it; usually this first describes – in a formal way – data and algorithms, then verifies the model and finally is (usually) used as a skeleton and To Do for the code.
This work’s goal is roughly comparable to what SPARK is to Ada, i.e. it is what allows Nim programs to be formally verified for correctness.</p>

<h2 id="a-more-elaborate-look">A more elaborate look</h2>

<p>What does it mean to say that some code is ‘correct’ anyway?</p>

<p>To answer that question we must first understand the context and see the full picture by widening our view and seeing what ‘software development’ means.
Software development can be described as a somewhat strange process that is about translating from – and understanding! – one language, namely that of a client, who thinks in <em>their</em> language and within <em>their</em> world, which may be astrophysics, sales, or manufacturing.
And they often don’t mention what they consider as well-known.
That’s the ‘incoming’ side.</p>

<p>On the other side, the ‘outgoing’ one, there is hardware which, as every developer with some experience knows, has its own treacherous spots.
There is a complex third part too, because usually the software we build does not run directly on hardware but on usually multiple intermediate layers such as the OS and libraries.</p>

<p>When some project is critical we definitely want a formal specification, also including pragmatic factors that are not relevant for the desired functionality itself but which are valuable or even critical for us to know.
One obvious example is a list of operating systems and architectures on which the code will have to run.
Another less obvious example is the question how closely the code will be observed (e.g. log files) and what failure responses are acceptable.</p>

<p>But again and keep that in mind: The statement that <em>our</em> code is proven to be correct is the <em>maximal</em> statement we can make, and frankly one that is very hard to achieve and very rare, because we only control 1 of many layers yet need to interact with them or depend on them.</p>

<h2 id="static-analysis">Static analysis</h2>

<p>Static (program) analysis is the formal chain element we as software developers are most concerned about.</p>

<p>The common “definition”, let me quote Wikipedia, <em>“Static program analysis is the analysis of computer software that is performed without actually executing programs …”</em> is correct but at the same time utterly insufficient and next to useless.</p>

<p>Why?
Because we must differentiate between a compiler writer and a developer or, in other words, between the question “is the code per se correct?” and “is the code logically correct?”.
From a compilers perspective the following code:</p>
<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">foo</span><span class="p">:</span> <span class="n">uint32</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># init var</span>
<span class="k">var</span> <span class="n">myArray</span> <span class="p">:</span> <span class="kt">array</span><span class="o">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">511</span><span class="p">,</span> <span class="n">uint32</span><span class="o">]</span> <span class="c"># our array</span>
<span class="c"># ...</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">myArray</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span> <span class="c"># assign some element to foo</span>
</code></pre></div></div>
<p>is correct.
The types match and the index is within bounds.
That is what a compiler cares about.</p>

<p>Does it make sense to assign <code class="language-plaintext highlighter-rouge">myArray[100]</code> to <code class="language-plaintext highlighter-rouge">foo</code> is <em>not</em> a question a compiler is concerned about.
You, however, should be concerned about it.
Why?
Because you want and need your code to do <em>something sensible</em> and what it needs to do, or in other words, you want your code to implement some algorithm.</p>

<p>What one <em>does</em> need static analysis for is basically to check algorithmic correctness - but if one implements that, one may as well make use of that capability to offload quite a bit of compiler work to static analysis.</p>

<p>Let me give you an example: ranges.
What is a range really?
It is basically the same as writing <code class="language-plaintext highlighter-rouge">var month : uint8 invar 0 &lt; month &lt;= 12</code>, i.e. a variable declaration with an invariant.</p>

<p>An invariant is a condition that must hold true during the life-time of the item (e.g. a variable) it is related to.
Most languages and SA tools allow that an invariant can not hold under some clearly defined conditions.</p>

<p>In fact, the example above is very close to the notation of an existing model checker with static analysis.
Now, if one has say a string array with the month names, accessing that array by a month number will always be within bounds if the month number is declared as above.</p>

<p>Putting it more generally: Always nail down your types as tightly as possible.
That very simple rule is an important rule to achieve error free code.</p>

<p>Let me give you another example: Nim’s <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> notation which provides an array’s (or sequence’s) lowest and highest valid index.
It too can be seen as an invariant, namely as <code class="language-plaintext highlighter-rouge">loop_var.min &lt;= loop_var &lt;= loop_var.high</code>.
If I wanted to get the same in C I would have to write a bunch of annotations for a static verifier like Frama-C.
Both of those examples deal with problems that are high up on the list of errors creating real-world vulnerabilities.</p>

<h2 id="static-analysis-part-2">Static analysis, part 2</h2>

<p>Let us look at a dead simple function that simply returns the argument value (of two args) that is lower, i.e. a <code class="language-plaintext highlighter-rouge">min</code> function.
A no-brainer, right?
Well, it depends on some factors, especially on the argument type.</p>

<p>If we declare it as <code class="language-plaintext highlighter-rouge">func min(a: int, b: int) : int</code> as it’s often done, then we may run into problems.
Say for example <code class="language-plaintext highlighter-rouge">a</code> is -128, <code class="language-plaintext highlighter-rouge">b</code> is 0, and <code class="language-plaintext highlighter-rouge">int</code> is 8 bits on some of the architectures we address.
What will the result be?
Presumably <code class="language-plaintext highlighter-rouge">-128</code>.</p>

<p>What we really want to do is to say that the result really is the minimum of the two values provided; but the minimum of two numbers is a <em>mathematical</em> statement.
Our goal is of a <em>mathematical</em> nature and what we really mean to achieve is something like:
“This function takes two numbers and returns the one with the lower value – <em>and</em> all three, the two parameters and the return value, are elements of the set of natural numbers, e.g. between -128 and +127”.</p>

<p>Now, assume that our <code class="language-plaintext highlighter-rouge">min</code> function came with the following specification:</p>
<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">):</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="n">require</span><span class="p">((</span><span class="n">INT_MIN</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">INT_MIN</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">))</span>
  <span class="n">ensure</span><span class="p">((</span><span class="n">INT_MIN</span> <span class="o">&lt;=</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)))</span>
</code></pre></div></div>

<p>This might look like a decent and sensible specification – but it isn’t, mainly for three reasons:</p>
<ol>
  <li>it’s too dependent on concrete circumstances (like word width), i.e. it’s what sometimes is called a “programmers spec” (as opposed to a mathematical spec) and only repeats the declaration in other words,</li>
  <li>the declaration (code) is probably not precise enough, i.e. ‘uintX’ (e.g. ‘uint16’) probably would be better and would implicitly make the spec shorter, and</li>
  <li>the spec isn’t clear and complete; what if <code class="language-plaintext highlighter-rouge">a == b</code>? In that case the postcondition won’t hold.</li>
</ol>

<p>Here is a better spec:</p>
<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="kt">int16</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="kt">int16</span><span class="p">):</span> <span class="kt">int16</span> <span class="o">=</span>
  <span class="n">ensure</span><span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">result</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">result</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div></div>

<p>The precondition is now automatically created by the compiler (based on the precise parameter type) and the, now also simpler, postcondition also covers the case where <code class="language-plaintext highlighter-rouge">a == b</code>.</p>

<p>“But I <em>want</em> a general and generic <code class="language-plaintext highlighter-rouge">min</code> function!” you say?
Well, then keep the first version above and just correct the postcondition, but think twice whether this really is what you want.
Rule of thumb: Nail everything (e.g. types) down as tightly as possible.</p>

<p>The main point of this example was however something different, namely that a postcondition (usually) should make statements related to what the function <em>does</em>, related to the algorithm implemented.
In other words: It should be sufficient for an observer to look <em>only</em> at the specification (and ignore the function body) in order to know what a function does.</p>

<p>Being at that I’ll quickly deviate to an issue that sometimes comes up in SA related discussions: “why would we need quantors, especially the <code class="language-plaintext highlighter-rouge">exists</code> quantor?”.
To answer that let me quickly introduce another <code class="language-plaintext highlighter-rouge">min</code> function, one that works on a list:</p>
<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">min</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="kt">seq</span><span class="o">[</span><span class="kt">int32</span><span class="o">]</span><span class="p">):</span> <span class="kt">int32</span> <span class="c"># find lowest val in list 'values'</span>
  <span class="n">postcondition</span><span class="p">(</span><span class="o">*???*</span><span class="p">)</span>
</code></pre></div></div>

<p>How are we to specify a postcondition (again: ideally one that also tells us what the function does) when we do not even know how many values the function will get passed?
Solution: We submit that there exists no element in the parameter list that is smaller than <code class="language-plaintext highlighter-rouge">result</code>.</p>

<p>We could also use the <code class="language-plaintext highlighter-rouge">all</code> quantor and play with the indices into the list but that would quickly get ugly.
It’s easier and, more importantly, more clear to state something like <code class="language-plaintext highlighter-rouge">ensures(not exists x in values: x &lt; result)</code> (read like “there is no element in the list <code class="language-plaintext highlighter-rouge">values</code> that is smaller than <code class="language-plaintext highlighter-rouge">result</code>”).</p>

<h2 id="static-analysis-part-3">Static analysis, part 3</h2>

<p>So, how does all that work?
There are different ways but at least nowadays pretty much all static analysers use Hoare triples, often also called “Design by Contract” (DbC), as a basic framework.
Hoare triples have 3 parts (no surprise there), namely a <em>precondition</em>, a <em>postcondition</em>, and optionally <em>invariants</em>.</p>

<p>They are useful to make statements about functions/procedures.
One typical and good way to describe it is a DbC “schoolbook” explanation:
A precondition is a promise the caller must fulfill, and a postcondition is a promise the callee must fulfill.
Or to put it very simply: if a function/procedure is called with a state (usually the parameters) meeting the preconditions then it <em>will definitely</em> meet its postconditions once it’s done (at function exit).</p>

<p>Small but important side note: most decent static analysers do not limit the state specifications in pre and postconditions to parameters and return values but can deal with <em>any reachable</em> state (e.g. global variables), although parameters and return values are the classical and most used case.</p>

<p>Unfortunately preconditions (often written as “require”) are often misunderstood and/or only (ab)used for simple parameter checking, e.g. to avoid null pointers.
And that’s halfway OK but preconditions can do much more.</p>

<p>For a simple example think of a function that is meant to only deal with an odd parameter value.
Prime numbers might be a use case (except for <code class="language-plaintext highlighter-rouge">2</code>).
Imagine that we wanted a function that only works on potential prime numbers, maybe a refining stage in a prime sieve.
The definition and preconditions might look like this:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">someSieve</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="n">uint64</span><span class="p">):</span> <span class="kt">bool</span> <span class="o">=</span> <span class="c"># primes aren't negative and can get big</span>
  <span class="n">where</span> <span class="n">precondition</span><span class="p">(</span><span class="n">lastDigit</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span><span class="o">[</span><span class="sc">'0'</span><span class="p">,</span><span class="sc">'5'</span><span class="o">]</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c"># body</span>
</code></pre></div></div>

<p>Again, note that this is telling the function itself, the static verifier, and any caller something, namely that the <code class="language-plaintext highlighter-rouge">num</code> parameter must not end in 0 or in 5 (prime numbers don’t end in 0 or 5), is greater than 2 (we don’t care about 1 and 2), is odd (an even number &gt; 2 can’t be prime), and is <code class="language-plaintext highlighter-rouge">&lt;= MAX_UINT64</code> (implicit via the type).</p>

<p>You noted my little trick with <code class="language-plaintext highlighter-rouge">lastDigit</code>?
Well, actually it’s not really a trick but a handy device: <code class="language-plaintext highlighter-rouge">lastDigit</code> is called a “ghost function”, which is a function that only exists at analysis/verification time (but normally not at run-time) but otherwise acts (almost) just like any function.
The full truth is that a ghost function (in almost any analyser offering them) is a purely mathematical (abstract) function, sometimes called “lemma”.
The interesting point for you is that a ghost function is useful for two things:</p>
<ol>
  <li>keeping your conditions and invariants looking clean (readability is important!), and</li>
  <li>to do what functions do, i.e. to be reusable (certain condition elements occur multiple times in a code corpus so it can be handy to put them into a ghost function); plus they vanish when compiling.</li>
</ol>

<p>Postconditions (often written as “ensure”) do quite the same thing but at function exit.
They specify state related conditions that the function guarantees to hold.</p>

<p>For example, if we stated that a given function never returns a negative value or a value greater than 42 we could express that like this</p>
<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">someFunc</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="kt">int32</span><span class="p">):</span> <span class="n">uint32</span> <span class="o">=</span>
  <span class="n">where</span> <span class="n">postcondition</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">42</span><span class="p">)</span>
</code></pre></div></div>

<p>Again, keep in mind that we make a <em>mathematical</em> statement albeit one that (usually) is related to <em>code</em> variables.
Although it should be noted that a decent static analyser also makes use of code elements, e.g. variable declarations, and includes them in its working.</p>

<p>Let’s quickly return to invariants because they play a major role with control mechanisms.
One particularly interesting point in static analysis is to make sure that loops properly terminate.</p>

<p>In languages where the loop control element, e.g. the variable <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">for(i = 0; i &lt; 42; i++)</code>, is read-only the problem is less critical, but in languages like C where the loop control element can be assigned to and might “jump around” quite a bit it can become really problematic.</p>

<p>Enter loop invariants (whose scope is typically limited to the loop).
One example is a so called ‘decrementor’ (editor note: not to be confused with <a href="https://vignette.wikia.nocookie.net/harrypotter/images/4/49/DementorConceptArt.jpg">Dementor</a> :)), a type of loop invariant which starts with some value (e.g. the max value of the control element) and counts down one after each loop iteration.
The analyser then tries to prove that the decrementor eventually reaches zero.</p>

<p>If conditions on the other hand are rather simple.
All the analyser must do is to look at the control element domain (its “range”) and for the two possible cases and the “pivot” point.
Remember, the analyser looks from a mathematical perspective.
Whether <code class="language-plaintext highlighter-rouge">i</code> is <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">41</code> in an <code class="language-plaintext highlighter-rouge">if(i &lt; 42)</code> clause makes little difference to an analyser.
What it sees is (assuming <code class="language-plaintext highlighter-rouge">i</code> being an <code class="language-plaintext highlighter-rouge">uint16</code>) that the domain of <code class="language-plaintext highlighter-rouge">i</code> is <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; 65536</code> and that 42 is within the domain and the “pivot” which means that the domain is split into two, namely <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; 42</code> and <code class="language-plaintext highlighter-rouge">42 &lt;= i &lt; 65536</code> which represent the entry gate to the <code class="language-plaintext highlighter-rouge">if</code> and the <code class="language-plaintext highlighter-rouge">else</code> part.</p>

<p>Now we are at a point where we can understand some more things, for example why some analysers (like Spark) are particularly helpful: it’s because they are intimately interwoven with the “host language” (Ada) and hence understand a lot of the information the compiler has available (and vice versa).
A more modest and limited but somewhat similar situation can be found with LLVM based analysers because they too have access to a lot of information albeit on the intermediate code level.</p>

<p>Nim too is in an excellent position to “get married” with static analysis due to the fact that it already has quite a few of “hidden invariants”, e.g. ranges and quite some other helpful factors and generally a quite clean basic syntax.
Probably even more importantly, Nim analysis doesn’t have to be based on some intermediate representation (and hence limited like e.g. LLVM) but can achieve a solution more similar to Spark.
Static analysis will also help Nim development tremendously because we can for example make it a rule that only adequately specified and successfully verified code will be accepted.</p>

<p>Solving isn’t the problem of static analysis any more, so what is a static analyser then?
It is the “bridge” between code and math/solving; it is what collects all the bits and pieces of information contained in the code, as well as the information provided by the person “annotating” the code and feeds it in a meaningful and relevant manner to the solver.</p>

<p>Sounds simple?
Well, yes, in theory but in real life it seems to be a complicated and hard job; the fact that only extremely few languages offer some SA facilities as well as the fact that SA is largely used only in rather few very sensitive projects strongly suggests that SA is <em>not</em> that simple.
Another fact that also seems to confirm that view is the fact that there are only about a dozen or two actually usable and used static analysers, all of which are either somewhat limited or way too complex for most developers including quite experienced ones.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Static Analysis – and I mean SA tightly coupled to its “host language” – offers two big things, namely:</p>
<ol>
  <li>the <em>only</em> way known so far to achieve justified confidence in code by <em>proving</em> it’s bug free, and</li>
  <li>an actually usable and even reasonably convenient way for mere mortal developers to achieve that confidence.</li>
</ol>

<p>With a caveat: a static analyser can’t do miracles; it largely can only prove correct what you feed to it.
If you don’t provide statements/conditions to be verified you won’t get much out of it.</p>

<p>You’ve probably heard of the fully verified seL4 kernel.
Well, they did take the hard route (back then they had to) and it took them about a decade of very skilled specialists work.
Compare that to Ada/Spark, probably still <em>the</em> example of a programming language coming (since some years) with a “built in” (actually quite tightly coupled) static analyser.
I still remember my first experience with it.
It was almost a dream having come true, not even just because it was something one could actually use without a PhD, but also because efficiency of use and even some convenience have a tangible and significant influence on our income as developers; we usually simply can’t afford to invest way more time in “annotation” than in writing code.</p>

<p>If there is one thing that you should take with you from this article it is this:
The compiler which is unnerving you with its warnings is <em>your friend</em>.
SA is some kind of an extended version of this.
SA is <em>your friend</em>, and a powerful one!
Make your choice: you can have the static analyser point out problematic spots to you, or you can have your customers pointing them out (and cursing at you).</p>

<p>The other point you should take away is that SA is (based on) <em>another</em> specification of what you are coding.
It is <em>not</em> a disadvantage but an <em>advantage</em> that it’s not exactly like code/your programming language.
It allows you to express your algorithms in a somewhat similar notation but having checked <em>the algorithm</em> as well as the program implementation.</p>

<p>In fact, I suggest to even go further and to consider the specification the important part and coding as some “secondary work”.
Programming is “just” the part of implementing the “how?”.
And indeed in highly sensitive environments, one <em>first</em> properly specifies (formally) <em>what</em> is done, what conditions must be met and what the state has to be before and after some module or procedure, and actually implementing the module and/or procedures is only the second to last step (the last step is verification and testing).</p>

<p>Also note one particularly useful and beautiful side effect of that:
if some procedure or module needed to be changed, say due to some administrative change, that change could not create harm to the whole system <em>iff</em> the specification (“annotations”) is sufficiently complete and tight.</p>

<p>I expect some future Nim version X (with a not complete but reasonable level of SA) to be a leap comparable to Ada/Spark, and potentially an even more significant leap because Nim is a language that is (or soon will be) much more used – and much easier to use – than Ada.
I’ll dance in joy once a Nim version with a <code class="language-plaintext highlighter-rouge">-d:verify</code> switch becomes available.</p>

        </div>
      </div>
    </div>
    <footer>
  <section class="content">
    <div class="pure-g">
      <div class="copyright pure-u-2-3">
        <p>
          Unless otherwise stated, the content of this page is
          licensed under the
          <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>
          license.
          Code displayed on this website is MIT licensed.
        </p>
        <p>
          This website is available on
          <a href="https://github.com/nim-lang/website">GitHub</a>
          and contributions are welcome.
          Original website design by
          <a href="https://github.com/dom96">Dominik Picheta</a> and
          <a href="https://github.com/Calinou">Hugo Locurcio</a>.
          Logo by <a href="https://github.com/josephwecker">Joseph Wecker</a>.
        </p>
      </div>
      <div class="pure-u-1-3 right-center">
        <a href="https://m.do.co/c/637ab907c7f4"><img src="/assets/img/do.png"/></a>
      </div>
    </div>
  </section>

</footer>
<script>
    (function(){
      function setTracking(a) {
        var url = a.href;
        a.onclick = function() {
          if (typeof(ga) !== "undefined") {
            ga('send', 'event', 'outbound', 'click', url, {
              'transport': 'beacon',
              'hitCallback': function(){document.location = url;}
            });
          }
        };
      }

      var a = document.getElementsByTagName("a");
      for (var i = 0; i < a.length; ++i) {
        if (a[i].hostname != location.hostname &&
            a[i].getAttribute("target") !== "_blank"
        ) {
          setTracking(a[i])
        }
      }
    })();
</script>

  </div>
  </body>
</html>
