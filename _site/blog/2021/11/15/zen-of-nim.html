<!doctype html>
<html lang="en">
  <head>
  <meta name="charset" content="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="The Nim programming language is a concise, fast programming language that compiles to C, C++ and JavaScript.">
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/assets/img/logo_bw.png" />

  
  <title>Zen of Nim - Nim Blog</title>
  
  <link rel="stylesheet" href="/assets/css/pure.min.css">
  <link rel="stylesheet" href="/assets/css/pure-grids-responsive.min.css">
  <link href="https://use.fontawesome.com/releases/v5.0.2/css/all.css" rel="stylesheet">
  <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->
  
  <link rel="stylesheet" href="/assets/css/highlight/github.css">
  

  <link rel="stylesheet" href="/assets/css/google-fonts.css">
  <link rel="stylesheet" href="/assets/css/main.css?t=1721738524015683587">

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-48159761-1', 'auto');
    ga('send', 'pageview');

  </script>

  <script defer data-domain="nim-lang.org" src="https://plausible.io/js/plausible.js"></script>

  <meta name="twitter:title" content="Zen of Nim">

  
  <meta name="twitter:description" content="Transcript of Zen of Nim presentation at NimConf2021">
  <meta property="og:description" content="Transcript of Zen of Nim presentation at NimConf2021">
  

  <meta name="twitter:site" content="@nim_lang">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://nim-lang.org/assets/img/twitter_banner.png">

  <meta property="og:title" content="Zen of Nim" />
  <meta property="og:site_name" content="Nim Programming Language" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://nim-lang.org/assets/img/twitter_banner.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="1000" />
  <meta property="og:image:height" content="500" />
  <meta property="og:image:alt" content="Nim Programming Language" />
</head>

  <body class="site">
    <header>
  <nav class="pure-menu pure-menu-horizontal pure-menu-scrollable">
    <div class="nav-content">
      <a href="/" class="pure-menu-heading pure-menu-link site-logo-container">
        <img class="site-logo" src="/assets/img/logo.svg" height="28" alt="Nim">
      </a>
      <ul class="pure-menu-list">
        
        <li class="pure-menu-item">
          <a href="/blog.html"
             class="pure-menu-link current">
            Blog
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/features.html"
             class="pure-menu-link ">
            Features
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/install.html"
             class="pure-menu-link ">
            Download
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/documentation.html"
             class="pure-menu-link ">
            Documentation
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://forum.nim-lang.org"
             class="pure-menu-link ">
            Forum
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="/donate.html"
             class="pure-menu-link ">
            Donate
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://github.com/nim-lang/Nim">Source</a>
        </li>
      </ul>
    </div>
    <div class="menu-fade"></div>
  </nav>
</header>

    <div class="site-content post-page">
      <div class="content">
        <div class="width-reduced">
          <h1 class="post-title">
            Zen of Nim
          </h1>
          <h3 class="post-meta">
            <span>
              <i class="far fa-calendar-alt" aria-hidden="true"></i>
              15 November 2021
            </span>
            
            <span>
              <i class="fa fa-user-circle" aria-hidden="true"></i>
              Andreas Rumpf (Araq), Pietro Peterlongo
            </span>
            
          </h3>
          <div class="sidebarblock">
  <div class="content">
    <div class="paragraph">
      This is a transcript of Araq's presentation at NimConf2021 delivered on June 26th
      (see the video on <a href="https://www.youtube.com/watch?v=D_G9h7DcIqM&amp;t=240s">youtube</a>,
      check the slides on <a href="https://github.com/Araq/nimconf2021">github</a>).
      It has been adapted to blog post format by <a href="https://github.com/pietroppeter">Pietro Peterlongo</a>
      and further reviewed by Araq.
    </div>
  </div>
</div>

<h1 id="zen-of-nim">Zen of Nim</h1>

<ol>
  <li>Copying bad design is not good design.</li>
  <li>If the compiler cannot reason about the code, neither can the programmer.</li>
  <li>Don’t get in the programmer’s way.</li>
  <li>Move work to compile-time: Programs are run more often than they are compiled.</li>
  <li>Customizable memory management.</li>
  <li>Concise code is not in conflict with readability, it enables readability.</li>
  <li>(Leverage meta programming to keep the language small.)</li>
  <li>Optimization is specialization: When you need more speed, write custom code.</li>
  <li>There should be one and only one programming language for everything. That language is Nim.</li>
</ol>

<blockquote>
  <p><strong>Editor’s note:</strong></p>

  <p>In the original presentation the Zen of Nim was given at the end (and without numbering).
Here we provide the Zen of Nim rules at the very beginning, numbered for ease of referencing.
The discussion of the above rules is done in the context of a general discussion of the language
and does not try to follow the order above.
The content is here presented following the original presentation,
starting from slide material and transcript of the video with minimal editing
(this results in an informal tone).</p>

  <p>Table of contents:</p>
  <ul>
    <li>Introduction</li>
    <li>Syntax (introduces Nim and motivates rule 6: concise code enables readability)</li>
    <li>A smart compiler (rule 2: compilers must be able to reason about code)</li>
    <li>Meta programming features (introduced through rule 1: copying bad design …)</li>
    <li>A practical language (rule 3: don’t get in programmer’s way)</li>
    <li>Customizable memory management (rule 5)</li>
    <li>Zen of Nim (recap and discussion of all the rules; rules 4, 7, 8, 9 are only discussed here)</li>
  </ul>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>In this blog post I will explain the philosophy of Nim language and why Nim can be useful for a wide range of application domains, such as:</p>

<ul>
  <li>scientific computing</li>
  <li>games</li>
  <li>compilers</li>
  <li>operating systems development</li>
  <li>scripting</li>
  <li>everything else</li>
</ul>

<p>“Zen” means that we will arrive at a set of rules (shown above) that guide the language design and evolution,
but I will go through these rules via examples.</p>

<h2 id="syntax">Syntax</h2>

<p>Let me introduce Nim via its syntax.
I am aware that most of you probably know the language, but to give you a gentle introduction even if you have not seen it before,
I will explain basic syntax and hopefully come to interesting conclusions.</p>

<p>Nim uses an <strong>indentation based syntax</strong> as inspired by Haskell or Python that <strong>fits Nim’s macro system</strong>.</p>

<h3 id="function-application">Function application</h3>

<p>Nim distinguishes between statements and expressions and most of the time an expression is a function application (also called a “procedure call”).
Function application uses the traditional mathy syntax with the parentheses: <code class="language-plaintext highlighter-rouge">f()</code>, <code class="language-plaintext highlighter-rouge">f(a)</code>, <code class="language-plaintext highlighter-rouge">f(a, b)</code>.</p>

<p>And here is the sugar:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Sugar</th>
      <th>Meaning</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">f a</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a)</code></td>
      <td><code class="language-plaintext highlighter-rouge">spawn log("some message")</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">f a, b</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a, b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">echo "hello ", "world"</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">a.f()</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a)</code></td>
      <td><code class="language-plaintext highlighter-rouge">db.fetchRow()</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">a.f</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a)</code></td>
      <td><code class="language-plaintext highlighter-rouge">mystring.len</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td><code class="language-plaintext highlighter-rouge">a.f(b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a, b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">myarray.map(f)</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td><code class="language-plaintext highlighter-rouge">a.f b</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a, b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">db.fetchRow 1</code></td>
    </tr>
    <tr>
      <td>7</td>
      <td><code class="language-plaintext highlighter-rouge">f"\n"</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(r"\n")</code></td>
      <td><code class="language-plaintext highlighter-rouge">re"\b[a-z*]\b"</code></td>
    </tr>
    <tr>
      <td>8</td>
      <td><code class="language-plaintext highlighter-rouge">f a: b</code></td>
      <td><code class="language-plaintext highlighter-rouge">f(a, b)</code></td>
      <td><code class="language-plaintext highlighter-rouge">lock x: echo "hi"</code></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>In rules 1 and 2 you can leave out the parentheses and there are examples so that you can see why that might be useful:
<code class="language-plaintext highlighter-rouge">spawn</code> looks like a keyword, which is good, since it does something special;
<code class="language-plaintext highlighter-rouge">echo</code> is also famous for leaving out the parentheses because usually you write these statements for debugging, thus you are in a hurry to get things done.</li>
  <li>You have a dot notation available and you can leave out parentheses (rules 3-6).</li>
  <li>Rule 7 is about string literals: <code class="language-plaintext highlighter-rouge">f</code> followed by a string without whitespace is still a call but the string is turned into a raw string literal,
which is very handy for regular expressions because regular expressions have their own idea of what a backslash is supposed to mean.</li>
  <li>Finally, in the last rule we can see that you can pass a block of code to the <code class="language-plaintext highlighter-rouge">f</code> with a <code class="language-plaintext highlighter-rouge">:</code> syntax.
The code block is usually the last argument you pass to the function. This can be used to create a custom <code class="language-plaintext highlighter-rouge">lock</code> statement.</li>
</ul>

<p>There is <strong>one exception</strong> to leaving out the parentheses, in the case you want to refer to <code class="language-plaintext highlighter-rouge">f</code> directly: <code class="language-plaintext highlighter-rouge">f</code> does not mean <code class="language-plaintext highlighter-rouge">f()</code>.
In the case of <code class="language-plaintext highlighter-rouge">myarray.map(f)</code> you do not want to invoke <code class="language-plaintext highlighter-rouge">f</code>, instead you want to pass the <code class="language-plaintext highlighter-rouge">f</code> itself to <code class="language-plaintext highlighter-rouge">map</code>.</p>

<h3 id="operators">Operators</h3>

<p>Nim has binary and unary operators:</p>

<ul>
  <li>Most of the time binary operators are simply invoked as <code class="language-plaintext highlighter-rouge">x @ y</code>
and unary operators as <code class="language-plaintext highlighter-rouge">@x</code>.</li>
  <li>There is no explicit distinction between operators and functions, and between binary and unary operators.</li>
</ul>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">`</span><span class="o">++</span><span class="p">`(</span><span class="n">x</span><span class="p">:</span> <span class="k">var</span> <span class="kt">int</span><span class="p">;</span> <span class="n">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">z</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>

<span class="k">var</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">70</span>
<span class="o">++</span><span class="n">g</span>
<span class="n">g</span> <span class="o">++</span> <span class="mi">7</span>
<span class="c"># operator in backticks is treated like an 'f':</span>
<span class="n">g</span><span class="p">.`</span><span class="o">++</span><span class="p">`(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">echo</span> <span class="n">g</span>  <span class="c"># writes 108</span>
</code></pre></div></div>

<ul>
  <li>Operators are simply sugar for functions.</li>
  <li>The operator token goes inside backticks (e.g. <code class="language-plaintext highlighter-rouge">++</code>) when the function is defined and it can be called as a function using backticks notation.</li>
</ul>

<p>Recall that the <code class="language-plaintext highlighter-rouge">var</code> keyword indicates mutability:</p>

<ul>
  <li>parameters are readonly unless declared as <code class="language-plaintext highlighter-rouge">var</code></li>
  <li><code class="language-plaintext highlighter-rouge">var</code> means “pass by reference” (it is implemented as a hidden pointer).</li>
</ul>

<h3 id="statements-vs-expressions">Statements vs expressions</h3>

<p>Statements require indentation:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># no indentation is needed for a single assignment statement:</span>
<span class="k">if</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="kp">false</span>

<span class="c"># indentation is needed for nested if statements:</span>
<span class="k">if</span> <span class="n">x</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">y</span> <span class="o">=</span> <span class="kp">true</span>

<span class="c"># indentation is needed, because two statements</span>
<span class="c"># follow the condition:</span>
<span class="k">if</span> <span class="n">x</span><span class="p">:</span>
  <span class="n">x</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">y</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div></div>

<p>You can also use semicolons instead of new lines but this is very uncommon in Nim.</p>

<p>Expressions are not really based on indentation so you are free to use additional white space within expressions:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">thisIsaLongCondition</span><span class="p">()</span> <span class="ow">and</span>
    <span class="n">thisIsAnotherLongCondition</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
  <span class="n">x</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre></div></div>

<p>This can be very handy for breaking up long lines.
As a rule of thumb you can have optional indentation after operators, parentheses and commas.</p>

<p>Finally the <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">case</code>, etc statements are also available as expressions, so they can produce a value.</p>

<p>As a simple example to conclude this section,
here is a full Nim program to show a little bit more of syntax.
If you are familiar with Python, this should be straightforward to read:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">indexOf</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span> <span class="n">x</span><span class="p">:</span> <span class="kt">set</span><span class="o">[</span><span class="kt">char</span><span class="o">]</span><span class="p">):</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0</span><span class="p">..</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span> <span class="k">return</span> <span class="n">i</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">let</span> <span class="n">whitespacePos</span> <span class="o">=</span> <span class="n">indexOf</span><span class="p">(</span><span class="s">"abc def"</span><span class="p">,</span> <span class="p">{</span><span class="sc">' '</span><span class="p">,</span> <span class="sc">'</span><span class="se">\t</span><span class="sc">'</span><span class="p">})</span>
<span class="n">echo</span> <span class="n">whitespacePos</span>
</code></pre></div></div>

<ul>
  <li>Nim uses static typing, so the parameters have types attached: the input parameter named <code class="language-plaintext highlighter-rouge">s</code> has type <code class="language-plaintext highlighter-rouge">string</code>;
<code class="language-plaintext highlighter-rouge">x</code> has the type “set of characters”; the function called <code class="language-plaintext highlighter-rouge">indexOf</code> produces an integer value as final result.</li>
  <li>You can iterate over the string index via the <code class="language-plaintext highlighter-rouge">for</code> loop, the goal is to find the position of the first character
inside the string that matches the given set of values.</li>
  <li>When calling the function, we construct a set of characters covering the “whitespace” property using curly parentheses (<code class="language-plaintext highlighter-rouge">{}</code>).</li>
</ul>

<p>Having talked mostly about syntax so far, the take-away here is our first Zen rule:</p>

<blockquote>
  <p>Concise code is not in conflict with readability, it enables readability.</p>
</blockquote>

<p>As you can see in the above tiny example, it is very easy to follow and to read because we basically leave out the symbols
that carry little meaning, such as curly braces for blocks or semicolons to terminate the statements.
This scales up, so in longer programs it is really helpful when you have less code to look at, because then you can
more easily figure out how the code is supposed to work or what it can do (without getting too much details).</p>

<p>Usually the argument is like: “the syntax is terse, so it is unreadable and all you want to do is to save typing work”;
in my opinion this totally misses the point, it is not about saving keystrokes or saving typing effort,
it is saving the effort when you <strong>look</strong> at the resulting code.
Programs are read way more often than they are written and when you read them it really helps if they are shorter.</p>

<h2 id="a-smart-compiler">A smart compiler</h2>

<p>The second rule for our Zen of Nim is:</p>

<blockquote>
  <p>The compiler must be able to reason about the code.</p>
</blockquote>

<p>This means we want:</p>

<ul>
  <li>Structured programming.</li>
  <li>Static typing!</li>
  <li>Static binding!</li>
  <li>Side effects tracking.</li>
  <li>Exception tracking.</li>
  <li>Mutability restrictions (the enemy is shared mutable state, but if the state is not shared it is fine to mutate it: we want to be able to do it precisely).</li>
  <li>Value based datatypes (aliasing is very hard to reason about!).</li>
</ul>

<p>We will see now what these points mean in detail.</p>

<h3 id="structured-programming">Structured programming</h3>

<p>In the following example the task is to count all the words in the file (given by <code class="language-plaintext highlighter-rouge">filename</code> as a <code class="language-plaintext highlighter-rouge">string</code>),
and produce a count table of strings, so in the end there will be entries for every word and how often it occurs in the text.</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">tables</span><span class="p">,</span> <span class="n">strutils</span>

<span class="k">proc </span><span class="nf">countWords</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="n">CountTable</span><span class="o">[</span><span class="kt">string</span><span class="o">]</span> <span class="o">=</span>
  <span class="sd">## Counts all the words in the file.</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">initCountTable</span><span class="o">[</span><span class="kt">string</span><span class="o">]</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">readFile</span><span class="p">(</span><span class="n">filename</span><span class="p">).</span><span class="n">split</span><span class="p">:</span>
    <span class="n">result</span><span class="p">.</span><span class="n">inc</span> <span class="n">word</span>
  <span class="c"># 'result' instead of 'return', no unstructed control flow</span>
</code></pre></div></div>

<p>Thankfully, the Nim standard library already offers us a <code class="language-plaintext highlighter-rouge">CountTable</code> so the first line of the <code class="language-plaintext highlighter-rouge">proc</code>
is the new count table.
<code class="language-plaintext highlighter-rouge">result</code> is built into Nim and it represents the return value so you
do not have to write <code class="language-plaintext highlighter-rouge">return result</code> which is unstructured programming,
because <code class="language-plaintext highlighter-rouge">return</code> immediately leaves every scope and returns back the result.
Nim does offer the <code class="language-plaintext highlighter-rouge">return</code> statement but we advise you to avoid it for this reason, since that is unstructured programming.</p>

<p>In the rest of the <code class="language-plaintext highlighter-rouge">proc</code>, we read the file into a single buffer, we split it to the get the single word and we count the word via
<code class="language-plaintext highlighter-rouge">result.inc</code>.</p>

<p>Structured programming means you have a single entry point into a block of code and a single exit point.</p>

<p>In the next example, I leave the <code class="language-plaintext highlighter-rouge">for</code> loop body in a more convoluted manner, with a <code class="language-plaintext highlighter-rouge">continue</code> statement:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">collection</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">isBad</span><span class="p">:</span> <span class="k">continue</span>
  <span class="c"># what do we know here at this point?</span>
  <span class="n">use</span> <span class="n">item</span>
</code></pre></div></div>

<ul>
  <li>For every item in this collection if the item is bad we continue and otherwise we use the item.</li>
  <li>What do I know after the continue statement? well, I know that the item is not bad.</li>
</ul>

<p>Why then not write it in this way, using structured programming:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">collection</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="p">.</span><span class="n">isBad</span><span class="p">:</span>
    <span class="c"># what do we know here at this point?</span>
    <span class="c"># that the item is not bad.</span>
    <span class="n">use</span> <span class="n">item</span>
</code></pre></div></div>

<ul>
  <li>The indentation here gives us clues about the invariances in our code, so that we can see much more easily
that when I <code class="language-plaintext highlighter-rouge">use item</code> the invariant holds that the item is not bad.</li>
</ul>

<p>If you prefer the <code class="language-plaintext highlighter-rouge">continue</code> and <code class="language-plaintext highlighter-rouge">return</code> statements, that is fine, it is not a crime to use them,
I use them myself if nothing else works, but you should try to avoid it and more importantly it means that
we will probably never add a more general go-to statement to the Nim programming language
because go-to is even more against the structured programming paradigm.
We want to be in this position where we can prove more and more properties about your code
and structured programming makes it much easier for a proof engine to help with this.</p>

<h3 id="static-typing">Static typing</h3>

<p>Another argument for static typing is that we really want you to use custom types
dedicated to the problem domain.</p>

<p>Here we have a little example showing you the <code class="language-plaintext highlighter-rouge">distinct string</code> feature (with <code class="language-plaintext highlighter-rouge">enum</code> and <code class="language-plaintext highlighter-rouge">set</code>):</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span>
  <span class="n">SandboxFlag</span> <span class="o">=</span> <span class="k">enum</span>         <span class="sd">## what the interpreter should allow</span>
    <span class="n">allowCast</span><span class="p">,</span>               <span class="sd">## allow unsafe language feature: 'cast'</span>
    <span class="n">allowFFI</span><span class="p">,</span>                <span class="sd">## allow the FFI</span>
    <span class="n">allowInfiniteLoops</span>       <span class="sd">## allow endless loops</span>

  <span class="n">NimCode</span> <span class="o">=</span> <span class="k">distinct</span> <span class="kt">string</span>

<span class="k">proc </span><span class="nf">runNimCode</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="n">NimCode</span><span class="p">;</span> <span class="n">flags</span><span class="p">:</span> <span class="kt">set</span><span class="o">[</span><span class="n">SandboxFlag</span><span class="o">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">allowCast</span><span class="p">,</span> <span class="n">allowFFI</span><span class="p">})</span> <span class="o">=</span>
  <span class="p">...</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">NimCode</code> can be stored as a <code class="language-plaintext highlighter-rouge">string</code> but it is a <code class="language-plaintext highlighter-rouge">distinct string</code> so it is a special type
with special rules.</li>
  <li>The <code class="language-plaintext highlighter-rouge">proc runNimCode</code> can run arbitrary Nim code that you passed to it, but it is a virtual machine
that can run the code and it can restrict what is possible.</li>
  <li>There is a sandbox environment in this example and there are custom properties that you might want to use.
For instance you can say: allow the nim <code class="language-plaintext highlighter-rouge">cast</code> operation (<code class="language-plaintext highlighter-rouge">allowCast</code>) or allow the function foreign interface (<code class="language-plaintext highlighter-rouge">allowFFI</code>);
the last option is about allowing Nim code to run into infinite loops (<code class="language-plaintext highlighter-rouge">allowInfiniteLoops</code>).</li>
  <li>We put the options in an ordinary <code class="language-plaintext highlighter-rouge">enum</code> and then we can produce a <code class="language-plaintext highlighter-rouge">set</code> of enums, indicating that
every option is independent of the others.</li>
</ul>

<p>If you compare the above to C for instance, where it is common to use the same mechanism, you lose the type safety:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define allowCast (1 &lt;&lt; 0)
#define allowFFI (1 &lt;&lt; 1)
#define allowInfiniteLoops (1 &lt;&lt; 2)
</span>
<span class="kt">void</span> <span class="nf">runNimCode</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">allowCast</span><span class="o">|</span><span class="n">allowFFI</span><span class="p">);</span>

<span class="n">runNimCode</span><span class="p">(</span><span class="s">"4+5"</span><span class="p">,</span> <span class="mi">700</span><span class="p">);</span> <span class="c1">// nobody stops us from passing 700</span>
</code></pre></div></div>

<ul>
  <li>When calling <code class="language-plaintext highlighter-rouge">runNimCode</code>, <code class="language-plaintext highlighter-rouge">flags</code> is only an unsigned integer and nobody stops you from passing the value 700
even though it does not make any sense.</li>
  <li>You need to use bit twiddling operations to define <code class="language-plaintext highlighter-rouge">allowCast</code>, … <code class="language-plaintext highlighter-rouge">allowInfiniteLoops</code>.</li>
</ul>

<p>You lose information here: even though it is very much in the programmer’s head what is really a valid
value for this <code class="language-plaintext highlighter-rouge">flags</code> argument, yet it is not written down in the program, so the compiler cannot really help you.</p>

<h3 id="static-binding">Static binding</h3>

<p>We want Nim to use static binding. Here is a modified “hello world” example:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span> <span class="s">"hello "</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="mi">99</span>
</code></pre></div></div>

<p>what happens is that the compiler rewrites the statment to:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span><span class="p">(</span><span class="o">[$</span><span class="s">"hello "</span><span class="p">,</span> <span class="o">$</span><span class="s">"world"</span><span class="p">,</span> <span class="o">$</span><span class="mi">99</span><span class="o">]</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">echo</code> is declared as: <code class="language-plaintext highlighter-rouge">proc echo(a: varargs[string, `$`]);</code></li>
  <li><code class="language-plaintext highlighter-rouge">$</code> (Nim’s <code class="language-plaintext highlighter-rouge">toString</code> operator) is applied to every argument.</li>
  <li>We use overloading (of the <code class="language-plaintext highlighter-rouge">$</code> operator in this case) instead of dynamic binding (as it would be done for example in C#).</li>
</ul>

<p>This mechanism is extensible:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">`$`</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">MyObject</span><span class="p">):</span> <span class="kt">string</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">s</span>
<span class="k">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="s">"xyz"</span><span class="p">)</span>
<span class="n">echo</span> <span class="n">obj</span>  <span class="c"># works</span>
</code></pre></div></div>

<ul>
  <li>Here I have my custom type <code class="language-plaintext highlighter-rouge">MyObject</code> and I define the <code class="language-plaintext highlighter-rouge">$</code> operator to actually return just the <code class="language-plaintext highlighter-rouge">s</code> field.</li>
  <li>Then, I construct a <code class="language-plaintext highlighter-rouge">MyObject</code> with value <code class="language-plaintext highlighter-rouge">"xyz"</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">echo</code> understands how to echo these objects of type <code class="language-plaintext highlighter-rouge">MyObject</code> because they have a dollar operator defined.</li>
</ul>

<h3 id="value-based-datatypes">Value based datatypes</h3>

<p>We want value based data types so that the program becomes easier to reason about.
I have already said we want to restrict the shared mutable state.
One solution that is usually overlooked by functional programming languages is that in order to do that
you want to restrict aliasing and not the mutation.
Mutation is very direct, convenient and efficient.</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span>
  <span class="n">Rect</span> <span class="o">=</span> <span class="k">object</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="kt">int</span>

<span class="c"># construction:</span>
<span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="mi">80</span><span class="p">)</span>

<span class="c"># field access:</span>
<span class="n">echo</span> <span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="s">" "</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">y</span>

<span class="c"># assignment does copy:</span>
<span class="k">var</span> <span class="n">other</span> <span class="o">=</span> <span class="n">r</span>
<span class="n">other</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">assert</span> <span class="n">r</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">12</span>
</code></pre></div></div>

<p>The fact that the assignment <code class="language-plaintext highlighter-rouge">other = r</code> performed a copy, means that there is no spooky action at a distance involved here,
there is only one access path to <code class="language-plaintext highlighter-rouge">r.x</code> and <code class="language-plaintext highlighter-rouge">other.x</code> is not an access path to the same memory location.</p>

<h3 id="side-effects-tracking">Side effects tracking</h3>

<p>We want to be able to track side effects.
Here is an example where the goal is to count the number of substrings inside a string.</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">strutils</span>

<span class="k">proc </span><span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="n">sub</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">int</span> <span class="p">{.</span><span class="n">noSideEffect</span><span class="p">.}</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="kp">true</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">echo</span> <span class="s">"i is: "</span><span class="p">,</span> <span class="n">i</span>  <span class="c"># error: 'echo' can have side effects</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="n">sub</span><span class="p">.</span><span class="n">len</span>
    <span class="n">inc</span> <span class="n">result</span>
</code></pre></div></div>

<p>Let us assume that this is not correct code and there is a debug <code class="language-plaintext highlighter-rouge">echo</code> statement.
The compiler would complain: you say proc has no side effect but echo produces a side effect,
so you are wrong, go fix your code!</p>

<p>The other aspect of Nim is that while the compiler is very smart and can help you, sometimes you need to get
work done and you must be able to override these very good defaults.</p>

<p>So if I say: “okay, I know this does produce a side effect, but I don’t care
because this is only code I added for debugging” you can say: “hey, cast this body of code
to a <code class="language-plaintext highlighter-rouge">noSideEffect</code> effect” and then the compiler is happy and says “ok, go ahead”:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">strutils</span>

<span class="k">proc </span><span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="n">sub</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">int</span> <span class="p">{.</span><span class="n">noSideEffect</span><span class="p">.}</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="kp">true</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
    <span class="p">{.</span><span class="k">cast</span><span class="p">(</span><span class="n">noSideEffect</span><span class="p">).}:</span>
      <span class="n">echo</span> <span class="s">"i is: "</span><span class="p">,</span> <span class="n">i</span>  <span class="c"># 'cast', so go ahead</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="n">sub</span><span class="p">.</span><span class="n">len</span>
    <span class="n">inc</span> <span class="n">result</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cast</code> means: “I know what I am doing, leave me alone”.</p>

<h3 id="exception-tracking">Exception tracking</h3>

<p>We want exception tracking!</p>

<p>Here I have my main <code class="language-plaintext highlighter-rouge">proc</code> and I want to say it raises nothing,
I want to be able to ensure that I handled every exception that can happen:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">os</span>

<span class="k">proc </span><span class="nf">main</span><span class="p">()</span> <span class="p">{.</span><span class="n">raises</span><span class="p">:</span> <span class="o">[]</span><span class="p">.}</span> <span class="o">=</span>
  <span class="n">copyDir</span><span class="p">(</span><span class="s">"from"</span><span class="p">,</span> <span class="s">"to"</span><span class="p">)</span>
  <span class="c"># Error: copyDir("from", "to") can raise an</span>
  <span class="c"># unlisted exception: ref OSError</span>
</code></pre></div></div>

<p>The compiler would complain and say
“look, this is wrong, <code class="language-plaintext highlighter-rouge">copyDir</code> can raise an unlisted exception, namely <code class="language-plaintext highlighter-rouge">OSError</code>”.
So you say, “fine, in fact I did not handle it”, so now I can claim
that <code class="language-plaintext highlighter-rouge">main</code> raises <code class="language-plaintext highlighter-rouge">OSError</code> and the compilers says: “you are right!”:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">os</span>

<span class="k">proc </span><span class="nf">main</span><span class="p">()</span> <span class="p">{.</span><span class="n">raises</span><span class="p">:</span> <span class="o">[</span><span class="n">OSError</span><span class="o">]</span><span class="p">.}</span> <span class="o">=</span>
  <span class="n">copyDir</span><span class="p">(</span><span class="s">"from"</span><span class="p">,</span> <span class="s">"to"</span><span class="p">)</span>
  <span class="c"># compiles :-)</span>
</code></pre></div></div>

<p>We want to be able to parametrize over this a little bit:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">x</span><span class="o">[</span><span class="n">E</span><span class="o">]</span><span class="p">()</span> <span class="p">{.</span><span class="n">raises</span><span class="p">:</span> <span class="o">[</span><span class="n">E</span><span class="o">]</span><span class="p">.}</span> <span class="o">=</span>
  <span class="k">raise</span> <span class="n">newException</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="s">"text here"</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
  <span class="n">x</span><span class="o">[</span><span class="n">ValueError</span><span class="o">]</span><span class="p">()</span>
<span class="k">except</span> <span class="n">ValueError</span><span class="p">:</span>
  <span class="n">echo</span> <span class="s">"good"</span>
</code></pre></div></div>

<ul>
  <li>I have a generic <code class="language-plaintext highlighter-rouge">proc x[E]</code> (<code class="language-plaintext highlighter-rouge">E</code> is the generic type), and I say: “whatever <code class="language-plaintext highlighter-rouge">E</code> you pass to this <code class="language-plaintext highlighter-rouge">x</code>,
that is what I am going to raise.</li>
  <li>Then I instantiate this <code class="language-plaintext highlighter-rouge">x</code> with this <code class="language-plaintext highlighter-rouge">ValueError</code> exception and the compiler is happy!</li>
</ul>

<p>I was really surprised that this works out of the box.
When I came up with this example I was quite sure the compiler would produce a bug, but it is already
handling this situation very well and I think the reason for that is that somebody else helped out and fixed this bug.</p>

<h3 id="mutability-restrictions">Mutability restrictions</h3>

<p>Here I am going to show and explain what the experimental <code class="language-plaintext highlighter-rouge">strictFuncs</code> switch does:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">experimental</span><span class="p">:</span> <span class="s">"strictFuncs"</span><span class="p">.}</span>

<span class="k">type</span>
  <span class="n">Node</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
    <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">:</span> <span class="n">Node</span>
    <span class="n">data</span><span class="p">:</span> <span class="kt">string</span>

<span class="k">func</span> <span class="n">len</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="k">var</span> <span class="n">it</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">it</span> <span class="o">!=</span> <span class="k">nil</span><span class="p">:</span>
    <span class="n">inc</span> <span class="n">result</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">next</span>
</code></pre></div></div>

<ul>
  <li>I have a <code class="language-plaintext highlighter-rouge">Node</code> type which is a <code class="language-plaintext highlighter-rouge">ref object</code> and <code class="language-plaintext highlighter-rouge">next</code> and <code class="language-plaintext highlighter-rouge">prev</code> are pointers to these kind of objects
(it is a doubly linked list). There is also a <code class="language-plaintext highlighter-rouge">data</code> field of type <code class="language-plaintext highlighter-rouge">string</code>.</li>
  <li>I have a function <code class="language-plaintext highlighter-rouge">len</code> and it counts the number of nodes that are in my linked list.</li>
  <li>The implementation is pretty straightforward: unless it is <code class="language-plaintext highlighter-rouge">nil</code> you count the node and then follow to <code class="language-plaintext highlighter-rouge">next</code> node.</li>
</ul>

<p>The crucial point is that via <code class="language-plaintext highlighter-rouge">strictFuncs</code> we tell the compiler that parameters are now <strong>deeply</strong> immutable,
so the compiler is fine with this code and it is also fine with this example:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">experimental</span><span class="p">:</span> <span class="s">"strictFuncs"</span><span class="p">.}</span>

<span class="k">func</span> <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">var</span> <span class="kt">seq</span><span class="o">[</span><span class="n">Node</span><span class="o">]</span><span class="p">;</span> <span class="n">y</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">L</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span>
  <span class="n">x</span><span class="p">.</span><span class="n">setLen</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">x</span><span class="o">[</span><span class="n">L</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span>
</code></pre></div></div>

<ul>
  <li>I want to <code class="language-plaintext highlighter-rouge">insert</code> something but it is a <code class="language-plaintext highlighter-rouge">func</code> so it is <strong>very</strong> strict about my mutations.</li>
  <li>I want to append to <code class="language-plaintext highlighter-rouge">x</code>, which is a sequence of nodes, so <code class="language-plaintext highlighter-rouge">x</code> is <strong>explicitly</strong> mutable
via the <code class="language-plaintext highlighter-rouge">var</code> keyword (and <code class="language-plaintext highlighter-rouge">y</code> is not mutable).</li>
  <li>I can set <code class="language-plaintext highlighter-rouge">x</code>’s length as the old length plus one and then overwrite what is in there, and this is fine.</li>
</ul>

<p>Finally, I can still mutate local state:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">doesCompile</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">var</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
  <span class="n">m</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"abc"</span>
</code></pre></div></div>

<p>I have a variable <code class="language-plaintext highlighter-rouge">m</code> of type <code class="language-plaintext highlighter-rouge">Node</code>, but it is freshly created and then I mutate it and set the <code class="language-plaintext highlighter-rouge">data</code> field and
since it is not connected to <code class="language-plaintext highlighter-rouge">n</code> the compiler is happy.</p>

<p>The semantics are: “you cannot mutate what is reachable via parameters, unless these parameters are explicitly marked as <code class="language-plaintext highlighter-rouge">var</code>”.</p>

<p>Here is an example where the compiler says:
“yeah, look, no, you are trying to mutate <code class="language-plaintext highlighter-rouge">n</code>, but you are in <code class="language-plaintext highlighter-rouge">strictFunc</code> mode so you are not allowed to do that”</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">experimental</span><span class="p">:</span> <span class="s">"strictFuncs"</span><span class="p">.}</span>

<span class="k">func</span> <span class="n">doesNotCompile</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">n</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"abc"</span>
</code></pre></div></div>

<p>We can now play these games and see how smart the compiler is.</p>

<p>Here I try to trick the compiler into accepting the code but I was not able to:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">experimental</span><span class="p">:</span> <span class="s">"strictFuncs"</span><span class="p">.}</span>

<span class="k">func</span> <span class="n">select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">b</span>

<span class="k">func</span> <span class="n">mutate</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">var</span> <span class="n">it</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">it</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">y</span> <span class="c"># &lt;-- is the statement that connected</span>
            <span class="c"># the mutation to the parameter</span>

  <span class="n">select</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">).</span><span class="n">data</span> <span class="o">=</span> <span class="s">"tricky"</span> <span class="c"># &lt;-- the mutation is here</span>
  <span class="c"># Error: an object reachable from 'n'</span>
  <span class="c"># is potentially mutated</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">select</code> is a helper function that takes two nodes and simply returns the second one.</li>
  <li>Then I want to mutate <code class="language-plaintext highlighter-rouge">n</code> but I assign it to <code class="language-plaintext highlighter-rouge">it</code>, and then <code class="language-plaintext highlighter-rouge">it</code> to <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">y</code> to <code class="language-plaintext highlighter-rouge">z</code>.</li>
  <li>Then I select either <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">z</code> and then mutate the <code class="language-plaintext highlighter-rouge">data</code> field and overwrite the string to value <code class="language-plaintext highlighter-rouge">"tricky"</code>.</li>
</ul>

<p>The compiler will tell you “Error, an object reachable from <code class="language-plaintext highlighter-rouge">n</code> is potentially mutated”
and it will point out the statement that connects the graph to this parameter.
What it does internally is: it has a notion of an abstract graph and it starts with
“every graph that is constructed is disjoint”, but depending on the body of your function,
these disjoint graphs can be connected.
When you mutate something, the graph is mutated and if it is connected to an input parameter,
then the compiler will complain.</p>

<p>So the second rule is:</p>

<blockquote>
  <p>If the compiler cannot reason about the code, neither can the programmer.</p>
</blockquote>

<p>We really want a smart compiler helping you out, because programming is quite hard.</p>

<h2 id="meta-programming-features">Meta programming features</h2>

<p>Another rule that is kind of famous by now is:</p>

<blockquote>
  <p>Copying bad design is not good design.</p>
</blockquote>

<p>If you say “hey, language X has feature F, let’s have that too!”, you copy
this design but you do not know if it is good or bad, because you did not
start from first principles.</p>

<p>So, “C++ has compile-time function evaluation, let’s have that too!”.
This is not a reason for adding compile-time function evaluation,
the reason why we have it (and we do it very differently from C++),
is the following: “We have many use cases for feature F”.</p>

<p>In this case F is the macro system:
“We need to be able to do locking, logging, lazy evaluation,
a typesafe Writeln/Printf, a declarative UI description language,
async and parallel programming! So instead of building these
features into the language, let’s have a macro system.”</p>

<p>Let’s have a look at these meta programming features.
Nim offers <strong>templates</strong> and <strong>macros</strong> for this purpose.</p>

<h3 id="templates-for-lazy-evaluation">Templates for lazy evaluation</h3>

<p>A template is a simple substitution mechanism.
Here I define a template named <code class="language-plaintext highlighter-rouge">log</code>:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
    <span class="n">echo</span> <span class="n">msg</span>

<span class="n">log</span><span class="p">(</span><span class="s">"x: "</span> <span class="o">&amp;</span> <span class="o">$</span><span class="n">x</span> <span class="o">&amp;</span> <span class="s">", y: "</span> <span class="o">&amp;</span> <span class="o">$</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<p>You can read it as some kind of function, but the crucial difference is that it expands the code directly in line
(where you invoke <code class="language-plaintext highlighter-rouge">log</code>).</p>

<p>You can compare the above to the following C code where <code class="language-plaintext highlighter-rouge">log</code> is a <code class="language-plaintext highlighter-rouge">#define</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define log(msg) \
  if (debug) { \
    print(msg); \
  }
</span>
<span class="n">log</span><span class="p">(</span><span class="s">"x: "</span> <span class="o">+</span> <span class="n">x</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">+</span> <span class="s">", y: "</span> <span class="o">+</span> <span class="n">y</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
</code></pre></div></div>

<p>It is quite similar! The reason why this is a template (or a <code class="language-plaintext highlighter-rouge">#define</code>) is that we want
this message parameter to be evaluated lazily, because in this example I do perform
expensive operations like string concatenations and turning variables into strings
and if <code class="language-plaintext highlighter-rouge">debug</code> is disabled this code should not be run.
The usual argument passing semantics are: “evaluate this expression and then call the function”,
but then inside the function you would notice that debug is disabled and that you do not need all this
information, so it does not have to be computed at all.
This is what this template achieves here for us, because it is expanded directly when invoked:
if <code class="language-plaintext highlighter-rouge">debug</code> is false then this complex expression of concats is not performed at all.</p>

<h3 id="templates-for-control-flow-abstraction">Templates for control flow abstraction:</h3>

<p>We can use templates for control flow abstractions.
If we want a <code class="language-plaintext highlighter-rouge">withLock</code> statement,
C# offers it is a language primitive, in Nim you do not have to build this into the language at all,
you just write a <code class="language-plaintext highlighter-rouge">withLock</code> template that acquires the <code class="language-plaintext highlighter-rouge">lock</code>:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="n">withLock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">var</span> <span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">acquire</span> <span class="n">lock</span>
    <span class="n">body</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">release</span> <span class="n">lock</span>

<span class="n">withLock</span> <span class="n">myLock</span><span class="p">:</span>
  <span class="n">accessProtectedResource</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">withLock</code> acquires the lock and finally releases the lock.</li>
  <li>In between the locking section the full body is run, which can be passed to <code class="language-plaintext highlighter-rouge">withLock</code> statement via colon indentation syntax.</li>
</ul>

<h3 id="macros-to-implement-dsls">Macros to implement DSLs</h3>

<p>You can use macros to implement DSLs (Domain Specific Languages).</p>

<p>Here is a DSL for describing html code:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">html</span> <span class="n">mainPage</span><span class="p">:</span>
  <span class="n">head</span><span class="p">:</span>
    <span class="n">title</span> <span class="s">"Zen of Nim"</span>
  <span class="n">body</span><span class="p">:</span>
    <span class="n">ul</span><span class="p">:</span>
      <span class="n">li</span> <span class="s">"A bunch of rules that make no sense."</span>

<span class="n">echo</span> <span class="n">mainPage</span><span class="p">()</span>
</code></pre></div></div>

<p>It produces:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;&lt;title&gt;</span>Zen of Nim<span class="nt">&lt;/title&gt;&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;ul&gt;</span>
      <span class="nt">&lt;li&gt;</span>A bunch of rules that make no sense.<span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h3 id="lifting">Lifting</h3>

<p>You can use meta programming for “lifting” operations that come up again and again in programming.</p>

<p>For example, we have square root in <code class="language-plaintext highlighter-rouge">math</code> for floating point numbers and now
I want to have a square root operation that works for a list of floating point numbers.
I could use a <code class="language-plaintext highlighter-rouge">map</code> call, but I can also create a dedicated <code class="language-plaintext highlighter-rouge">sqrt</code> function:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">math</span>

<span class="k">template</span> <span class="n">liftFromScalar</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">proc </span><span class="nf">fname</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">openArray</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">):</span> <span class="kt">seq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span> <span class="o">=</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">newSeq</span><span class="o">[</span><span class="n">typeof</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0</span><span class="p">..</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">:</span>
      <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">fname</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>

<span class="c"># make sqrt() work for sequences:</span>
<span class="n">liftFromScalar</span><span class="p">(</span><span class="n">sqrt</span><span class="p">)</span>
<span class="n">echo</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">@[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">36.0</span><span class="o">]</span><span class="p">)</span>
<span class="c"># =&gt; @[2.0, 4.0, 5.0, 6.0]</span>
</code></pre></div></div>
<ul>
  <li>We pass <code class="language-plaintext highlighter-rouge">fname</code> to the template and <code class="language-plaintext highlighter-rouge">fname</code> is applied to every element of the sequence.</li>
  <li>The final name of the <code class="language-plaintext highlighter-rouge">proc</code> is also <code class="language-plaintext highlighter-rouge">fname</code> (in this case <code class="language-plaintext highlighter-rouge">sqrt</code>).</li>
</ul>

<h3 id="declarative-programming">Declarative programming</h3>

<p>You can use templates to turn imperative code into declarative code.</p>

<p>Here I have an example extracted from our test suite:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">threadTests</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="k">var</span> <span class="n">Results</span><span class="p">,</span> <span class="n">cat</span><span class="p">:</span> <span class="n">Category</span><span class="p">,</span>
                  <span class="n">options</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">template</span> <span class="n">test</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">untyped</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">testSpec</span> <span class="n">r</span><span class="p">,</span> <span class="n">makeTest</span><span class="p">(</span><span class="s">"tests/threads"</span> <span class="o">/</span> <span class="n">filename</span><span class="p">,</span>
      <span class="n">options</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">actionRun</span><span class="p">)</span>
    <span class="n">testSpec</span> <span class="n">r</span><span class="p">,</span> <span class="n">makeTest</span><span class="p">(</span><span class="s">"tests/threads"</span> <span class="o">/</span> <span class="n">filename</span><span class="p">,</span>
      <span class="n">options</span> <span class="o">&amp;</span> <span class="s">" -d:release"</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">actionRun</span><span class="p">)</span>
    <span class="n">testSpec</span> <span class="n">r</span><span class="p">,</span> <span class="n">makeTest</span><span class="p">(</span><span class="s">"tests/threads"</span> <span class="o">/</span> <span class="n">filename</span><span class="p">,</span>
      <span class="n">options</span> <span class="o">&amp;</span> <span class="s">" --tlsEmulation:on"</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">actionRun</span><span class="p">)</span>

  <span class="n">test</span> <span class="s">"tactors"</span>
  <span class="n">test</span> <span class="s">"tactors2"</span>
  <span class="n">test</span> <span class="s">"threadex"</span>
</code></pre></div></div>

<p>There are threading tests called <code class="language-plaintext highlighter-rouge">tactors</code>, <code class="language-plaintext highlighter-rouge">tactors2</code> and <code class="language-plaintext highlighter-rouge">threadex</code> and every single of these tests
runs in three different configurations: with the default options, default options plus release switch,
default options plus thread local storage emulation.
This <code class="language-plaintext highlighter-rouge">threadTests</code> call takes many parameters (like category and options and filename),
which is just distracting when you copy and paste it over and over again,
so here we want to say “I have a test that is called <code class="language-plaintext highlighter-rouge">tactors</code>, I have a test that is called <code class="language-plaintext highlighter-rouge">tactors2</code>
and I have a test that is called <code class="language-plaintext highlighter-rouge">threadex</code>” and by shortening this you are now working at the level of abstraction
that you actually want to work on:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="s">"tactors"</span>
<span class="n">test</span> <span class="s">"tactors2"</span>
<span class="n">test</span> <span class="s">"threadex"</span>
</code></pre></div></div>

<p>You can shorten this further, since all these test invocations are kind of annoying.
What I really want to say is:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span> <span class="s">"tactors"</span><span class="p">,</span> <span class="s">"tactors2"</span><span class="p">,</span> <span class="s">"threadex"</span>
</code></pre></div></div>

<p>Here is a simple macro that does that:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">macros</span>

<span class="k">macro</span> <span class="n">apply</span><span class="p">(</span><span class="n">caller</span><span class="p">:</span> <span class="n">untyped</span><span class="p">;</span>
            <span class="n">args</span><span class="p">:</span> <span class="n">varargs</span><span class="o">[</span><span class="n">untyped</span><span class="o">]</span><span class="p">):</span> <span class="n">untyped</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">newStmtList</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
    <span class="n">result</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">newCall</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

<span class="n">apply</span> <span class="n">test</span><span class="p">,</span> <span class="s">"tactors"</span><span class="p">,</span> <span class="s">"tactors2"</span><span class="p">,</span> <span class="s">"threadex"</span>
</code></pre></div></div>

<p>Since it is so simple, it is not able to accomplish the full thing and you need to say <code class="language-plaintext highlighter-rouge">apply test</code>.
This macro produces a list of statements, and every statement inside this list is actually a call expression
calling this <code class="language-plaintext highlighter-rouge">test</code> with <code class="language-plaintext highlighter-rouge">a</code> (<code class="language-plaintext highlighter-rouge">a</code> is the current argument and we iterate over every argument).</p>

<p>The details are not really that important, the crucial insight here is that Nim gives you
the capabilities of doing these things and once you get used to it, it is remarkably easy.</p>

<h3 id="typesafe-writelnprintf">Typesafe Writeln/Printf</h3>

<p>The next example is a macro system that gives us a type safe <code class="language-plaintext highlighter-rouge">printf</code>:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">write</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">File</span><span class="p">;</span> <span class="n">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">echo</span> <span class="n">a</span>
<span class="k">proc </span><span class="nf">write</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">File</span><span class="p">;</span> <span class="n">a</span><span class="p">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">=</span> <span class="n">echo</span> <span class="n">a</span>
<span class="k">proc </span><span class="nf">write</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">File</span><span class="p">;</span> <span class="n">a</span><span class="p">:</span> <span class="kt">float</span><span class="p">)</span> <span class="o">=</span> <span class="n">echo</span> <span class="n">a</span>

<span class="k">proc </span><span class="nf">writeNewline</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">File</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">echo</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

<span class="k">macro</span> <span class="n">writeln</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">File</span><span class="p">;</span> <span class="n">args</span><span class="p">:</span> <span class="n">varargs</span><span class="o">[</span><span class="n">typed</span><span class="o">]</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">newStmtList</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
    <span class="n">result</span><span class="p">.</span><span class="n">add</span> <span class="n">newCall</span><span class="p">(</span><span class="s">bindSym"write"</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">result</span><span class="p">.</span><span class="n">add</span> <span class="n">newCall</span><span class="p">(</span><span class="s">bindSym"writeNewline"</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Same thing as before, we create a statement list in the first line of the macro and then we iterate over every argument
and we produce a function call called <code class="language-plaintext highlighter-rouge">write</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">bindSym"write"</code> binds <code class="language-plaintext highlighter-rouge">write</code> but this is not a single <code class="language-plaintext highlighter-rouge">write</code>, it is
an overloaded operation because I have three <code class="language-plaintext highlighter-rouge">write</code> operations at the start of the example (for <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">bool</code> and <code class="language-plaintext highlighter-rouge">float</code>),
and overloading resolution kicks in and picks the right <code class="language-plaintext highlighter-rouge">write</code> operation.</li>
  <li>Finally, the last line of the macro, there is a call to a <code class="language-plaintext highlighter-rouge">writeNewline</code> function that was declared earlier (which produces a new line).</li>
</ul>

<h2 id="a-practical-language">A practical language</h2>

<p>The compiler is smart but:</p>

<blockquote>
  <p>Don’t get in the programmer’s way</p>
</blockquote>

<p>We have a tremendous amount of code written in C++, C and Javascript that programmers really need to reuse.
We accomplishing this <strong>interoperability with C++, C and JavaScript</strong>, by compiling Nim to these languages.
Note that this is for interoperability, the philosophy is not:
“let’s use C++ plus Nim, because Nim does not offer some features that are required to get the job done”.
Nim does indeed offer low level features such as:</p>

<ul>
  <li>bit twiddling,</li>
  <li>unsafe type conversions (“cast”),</li>
  <li>raw pointers.</li>
</ul>

<p>Interfacing with C++ is the last resort, usually we want you to write Nim code
and not leave Nim code, but then the real world kicks in and says:
“hey, there’s a bunch of code already written in these languages,
how about you make the interoperability with these systems very good”.</p>

<p>We do not want Nim to be just one language out of many and then you use different programming languages
to accomplish your system. Ideally, you only use the Nim language because that is much cheaper to do.
Then you can hire programmers that only know a single programming language rather than four (or whatever you need).</p>

<p>The interoperability story goes so far that we actually offer an <code class="language-plaintext highlighter-rouge">emit</code> statement where you can directly put
foreign code into your Nim code and the compiler merges these two things together in the final file.</p>

<p>Here is an example:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">emit</span><span class="p">:</span> <span class="s">"""
static int cvariable = 420;
"""</span><span class="p">.}</span>

<span class="k">proc </span><span class="nf">embedsC</span><span class="p">()</span> <span class="o">=</span>
  <span class="k">var</span> <span class="n">nimVar</span> <span class="o">=</span> <span class="mi">89</span>
  <span class="p">{.</span><span class="n">emit</span><span class="p">:</span> <span class="o">[</span><span class="s">"""fprintf(stdout, "%d\n", cvariable + (int)"""</span><span class="p">,</span>
    <span class="n">nimVar</span><span class="p">,</span> <span class="s">");"</span><span class="o">]</span><span class="p">.}</span>

<span class="n">embedsC</span><span class="p">()</span>
</code></pre></div></div>
<p>You can emit a <code class="language-plaintext highlighter-rouge">static int cvariable</code> and the communication is two way,
so you can emit a <code class="language-plaintext highlighter-rouge">fprintf</code> statement where the variable <code class="language-plaintext highlighter-rouge">nimVar</code> is actually coming from Nim
(using the bracket notation you can have both strings and name expressions in the same environment).
The C code can use Nim code and viceversa.
However, this is really not a good way to do this interfacing,
it is just to show that we want you to be able to get things done.</p>

<p>A much better way for interoperability is where you can actually tell Nim: “hey, there is an <code class="language-plaintext highlighter-rouge">fprintf</code> function, 
it is coming from C and these are its types, I want to be able to call it”.
Still, the <code class="language-plaintext highlighter-rouge">emit</code> pragma gets the point across very well that <strong>we want this language to be practical</strong>.</p>

<h2 id="customizable-memory-management">Customizable memory management</h2>

<p>Now a different topic, so far we did not talk about memory management.
In the newer Nim versions it is based on destructors
and it is called the <code class="language-plaintext highlighter-rouge">gc:arc</code> or <code class="language-plaintext highlighter-rouge">gc:orc</code> mode.
Destructors and ownership are hopefully familiar notions from C++ and Rust.</p>

<p>The <code class="language-plaintext highlighter-rouge">sink</code> parameter here means that the function gets ownership of the string
(and then it does not do anything with <code class="language-plaintext highlighter-rouge">x</code>):</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">sink</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">discard</span> <span class="s">"do nothing"</span>

<span class="n">f</span> <span class="s">"abc"</span>
</code></pre></div></div>

<p>The question is: “did I produce a memory leak? what happens?”.
You can ask the Nim compiler:
“hey, expand this function <code class="language-plaintext highlighter-rouge">f</code> for me; show me where the destructors are, where moves are performed,
where deep copies are performed”
(compile with <code class="language-plaintext highlighter-rouge">nim c --gc:orc --expandArc:f $file</code>).</p>

<p>The compiler would tell you “look, function <code class="language-plaintext highlighter-rouge">f</code> is actually your discard statement and I added this call
to the destructor at the end”:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">sink</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">discard</span> <span class="s">"do nothing"</span>
  <span class="p">`</span><span class="o">=</span><span class="n">destroy</span><span class="p">`(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The nice thing is that <strong>Nim’s intermediate language is Nim itself</strong>,
so Nim is this one language that can express everything very well.</p>

<p>Here I have a different example:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">g</span><span class="p">:</span> <span class="kt">string</span>

<span class="k">proc </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">sink</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">g</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">f</span> <span class="s">"abc"</span>
</code></pre></div></div>

<p>This time I take ownership of <code class="language-plaintext highlighter-rouge">x</code> and I really do something with the ownership,
namely I put <code class="language-plaintext highlighter-rouge">x</code> into this global variable <code class="language-plaintext highlighter-rouge">g</code>.
Again, we can ask the compiler what does it do and the compiler says:
“this is a move operation, it is called <code class="language-plaintext highlighter-rouge">=sink</code>”.
So we move the <code class="language-plaintext highlighter-rouge">x</code> into the <code class="language-plaintext highlighter-rouge">g</code> and the move takes care of freeing what is inside the <code class="language-plaintext highlighter-rouge">g</code>
(if there is something) and then it takes <code class="language-plaintext highlighter-rouge">x</code>’s value over:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">g</span><span class="p">:</span> <span class="kt">string</span>

<span class="k">proc </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">sink</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="p">`</span><span class="o">=</span><span class="n">sink</span><span class="p">`(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">f</span> <span class="s">"abc"</span>
</code></pre></div></div>

<p>What it really did, and unfortunately that is not really visible here, is that
it says: “okay, <code class="language-plaintext highlighter-rouge">x</code> is moved into <code class="language-plaintext highlighter-rouge">g</code> and then we say <code class="language-plaintext highlighter-rouge">x</code> was moved
and call the destructor”, but these <code class="language-plaintext highlighter-rouge">wasMoved</code> and <code class="language-plaintext highlighter-rouge">=destroy</code> calls cancel out so
that the compiler optimized this for us:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">g</span><span class="p">:</span> <span class="kt">string</span>

<span class="k">proc </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">sink</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
  <span class="p">`</span><span class="o">=</span><span class="n">sink</span><span class="p">`(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="c"># optimized out:</span>
  <span class="n">wasMoved</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">`</span><span class="o">=</span><span class="n">destroy</span><span class="p">`(</span><span class="n">x</span><span class="p">)</span>

<span class="n">f</span> <span class="s">"abc"</span>
</code></pre></div></div>

<h3 id="a-custom-container">A custom container</h3>

<p>You can use these moves, destructors and copy assignments to create custom data structures.</p>

<p>Here I have a short example, but I will not go into much details.</p>

<p><strong>Destructor</strong>:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span>
  <span class="n">myseq</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span> <span class="o">=</span> <span class="k">object</span>
    <span class="n">len</span><span class="p">,</span> <span class="n">cap</span><span class="p">:</span> <span class="kt">int</span>
    <span class="n">data</span><span class="p">:</span> <span class="k">ptr</span> <span class="n">UncheckedArray</span><span class="o">[</span><span class="n">T</span><span class="o">]</span>

<span class="k">proc </span><span class="nf">`=destroy`</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">var</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span> <span class="o">!=</span> <span class="k">nil</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0</span><span class="p">..</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">:</span> <span class="p">`</span><span class="o">=</span><span class="n">destroy</span><span class="p">`(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
    <span class="n">dealloc</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Move operator</strong>:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">`=sink`</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="k">var</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">;</span> <span class="n">b</span><span class="p">:</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">)</span> <span class="o">=</span>
  <span class="c"># move assignment, optional.</span>
  <span class="c"># Compiler is using `=destroy` and</span>
  <span class="c"># `copyMem` when not provided</span>
  <span class="p">`</span><span class="o">=</span><span class="n">destroy</span><span class="p">`(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">len</span>
  <span class="n">a</span><span class="p">.</span><span class="n">cap</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">cap</span>
  <span class="n">a</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">data</span>
</code></pre></div></div>

<p><strong>Assignment operator</strong>:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">`=copy`</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="k">var</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">;</span> <span class="n">b</span><span class="p">:</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">)</span> <span class="o">=</span>
  <span class="c"># do nothing for self-assignments:</span>
  <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">data</span><span class="p">:</span> <span class="k">return</span>
  <span class="p">`</span><span class="o">=</span><span class="n">destroy</span><span class="p">`(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">len</span>
  <span class="n">a</span><span class="p">.</span><span class="n">cap</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">cap</span>
  <span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="n">data</span> <span class="o">!=</span> <span class="k">nil</span><span class="p">:</span>
    <span class="n">a</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="k">cast</span><span class="o">[</span><span class="n">typeof</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="o">]</span><span class="p">(</span><span class="n">alloc</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">cap</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0</span><span class="p">..</span><span class="o">&lt;</span><span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">:</span>
      <span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</code></pre></div></div>

<p><strong>Accessors</strong></p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">proc </span><span class="nf">add</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">var</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">;</span> <span class="n">y</span><span class="p">:</span> <span class="n">sink</span> <span class="n">T</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">.</span><span class="n">cap</span><span class="p">:</span> <span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="o">[</span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span>
  <span class="n">inc</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span>

<span class="k">proc </span><span class="nf">`[]`</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">;</span> <span class="n">i</span><span class="p">:</span> <span class="n">Natural</span><span class="p">):</span> <span class="n">lent</span> <span class="n">T</span> <span class="o">=</span>
  <span class="n">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span>
  <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>

<span class="k">proc </span><span class="nf">`[]=`</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">var</span> <span class="n">myseq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">;</span> <span class="n">i</span><span class="p">:</span> <span class="n">Natural</span><span class="p">;</span> <span class="n">y</span><span class="p">:</span> <span class="n">sink</span> <span class="n">T</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">len</span>
  <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span>
</code></pre></div></div>

<p>The point here is that destructors, move operators, … can be written by you for your
custom containers and then they work well with Nim’s built-in containers,
but it also gives you very precise control over the memory allocations and how they are done.</p>

<p>So another Zen rule is:</p>

<blockquote>
  <p>Customizable memory management</p>
</blockquote>

<h2 id="zen-of-nim-1">Zen of Nim</h2>

<p>Here are the rules once again as a summary:</p>

<ul>
  <li><strong>Copying bad design is not good design</strong>: we want to create good design by reasoning from first principles
about the problem.</li>
  <li><strong>If the compiler cannot reason about the code, neither can the programmer</strong>.</li>
  <li>However, <strong>don’t get in the programmer’s way</strong>. The compiler is a smart dog: you can teach it new tricks
and it really helps you out, it can perform tasks for you like carrying a newspaper, but in the end
the programmer is still smarter than the compiler.</li>
  <li>We want to <strong>move work to compile-time</strong> because <strong>programs are run more often than they are compiled</strong>.</li>
  <li>We want <strong>customizable memory management</strong>.</li>
  <li><strong>Concise code is not in conflict with readability, it enables readability</strong>.</li>
  <li>There was this rule of Zen that was like <strong>leverage meta programming to keep the language small</strong>,
however it is hard to say that and keep a straight face when Nim really offers quite a lot of features.
There is a friction between “we want the language to be complete” and “we want the language to be minimal”.
The older Nim gets the more Nim is about completeness (all minimal languages grow to serve certain needs).</li>
  <li><strong>Optimization is specialization</strong>. I have not talked about this yet, but <strong>when you need more speed</strong>,
you should really consider to <strong>write custom code</strong>. The Nim standard library cannot offer everything to everybody
and for us it is also much harder to give you the best library for everything, because the best library must be general purpose, 
it must be the fastest library, it must have the least amount of overhead for your compile times, and that is very hard to accomplish.
It is much easier to say “ok, Nim offers this as a standard library, but here I wrote this myself in 10 lines and I can
benchmark it and usually my custom code is faster, because it is hand tailored to the application that I am writing”.
So the really is: specialize your code and then it will run fast.</li>
  <li>Finally, <strong>there should be one and only one programming language for everything. That language is Nim.</strong></li>
</ul>

<p>Thank you for reading!</p>

        </div>
      </div>
    </div>
    <footer>
  <section class="content">
    <div class="pure-g">
      <div class="copyright pure-u-2-3">
        <p>
          Unless otherwise stated, the content of this page is
          licensed under the
          <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>
          license.
          Code displayed on this website is MIT licensed.
        </p>
        <p>
          This website is available on
          <a href="https://github.com/nim-lang/website">GitHub</a>
          and contributions are welcome.
          Original website design by
          <a href="https://github.com/dom96">Dominik Picheta</a> and
          <a href="https://github.com/Calinou">Hugo Locurcio</a>.
          Logo by <a href="https://github.com/josephwecker">Joseph Wecker</a>.
        </p>
      </div>
      <div class="pure-u-1-3 right-center">
        <a href="https://m.do.co/c/637ab907c7f4"><img src="/assets/img/do.png"/></a>
      </div>
    </div>
  </section>

</footer>
<script>
    (function(){
      function setTracking(a) {
        var url = a.href;
        a.onclick = function() {
          if (typeof(ga) !== "undefined") {
            ga('send', 'event', 'outbound', 'click', url, {
              'transport': 'beacon',
              'hitCallback': function(){document.location = url;}
            });
          }
        };
      }

      var a = document.getElementsByTagName("a");
      for (var i = 0; i < a.length; ++i) {
        if (a[i].hostname != location.hostname &&
            a[i].getAttribute("target") !== "_blank"
        ) {
          setTracking(a[i])
        }
      }
    })();
</script>

  </div>
  </body>
</html>
